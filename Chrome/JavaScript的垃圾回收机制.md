#### 概念
浏览器的 Javascript 具有自动垃圾回收机制(GC:Garbage Collecation)，也就是说，执行环境会负责管理代码执行过程中使用的内存。其原理是：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大并且 GC 时停止响应其他操作，所以垃圾回收器会按照固定的时间间隔周期性的执行。

不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，而闭包中由于内部函数的原因，外部函数并不能算是结束。

以代码为例
```javascript
function fn1() {
    var obj = {name: 'hanzichi', age: 10};
}
function fn2() {
    var obj = {name: 'hanzichi', age: 10};
    return obj;
}

var a = fn1();
var b = fn2();

```
我们来看代码是如何执行的。首先声明了两个函数，分别叫做 fn1 和 fn2，当 fn1 被调用时，进入 fn1 的环境，会开辟一块内存存放对象 {name:'hanzichi',age:10}，而当调用结束后，出了 fn1 的环境，那么该块内存会被 JS 引擎中的垃圾回收器自动释放；在 fn2 被调用的过程中，返回的对象被全局变量 b 所指向，所以该块内存并不会被释放。

这里问题就出现了：到底哪个变量是没有用的？所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存。用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：标记清除和引用计数。引用计数不太常用，标记清除较为常用。

#### 标记清除法
这是javascript中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。
举个例子来看：
```javascript
function fun() {
    var a = 1;  // 变量a被标记，‘进入环境’
    var b = 2;  // 变量b被标记，‘进入环境’
}

// 执行函数，函数被执行后局部变量a,b被标记离开环境，GC轮询回收
fun();
```
垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。到目前为止，IE9+、Firefox、Opera、Chrome、Safari 的 JS 实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。
　　
#### 引用计数
引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为 0 的值所占用的内存。

举个例子来看
```javascript
function fun() {
    var a = {};  // a指向了一个对象，此对象的引用次数为1，1
    var b = a; // a的值赋予了b，a,b的对应的值的引用次数加1，2
    var c = a; // a的值赋予了c，对象的引用次数再次加1，3
    var b = {}; // b的指向被改变，原值的引用次数减1，新值的引用次数加1
}

fun();
```
以上代码 a 和 b 的引用次数分别是2，1， fn 执行完毕后，两个对象都已经离开环境，在标记清除方式下是没有问题的，但是在引用计数策略下，因为 a 和 b 的引用次数不为 0，所以不会被垃圾回收器回收内存，如果 fn函数被大量调用，a和b就会大量占用内存，继而造成内存泄露。在 IE7 与 IE8 上，内存直线上升。

引用计数法清除的弊端：

```javascript
window.onload = function outerFunction(){
    var obj = document.getElementById"element");
    obj.onclick = function innerFunction(){};
};
```
这段代码看起来没什么问题，但是 obj 引用了 document.getElementById('element')，而 document.getElementById('element') 的 onclick 方法会引用外部环境中的变量，自然也包括 obj，是不是很隐蔽啊。(在比较新的浏览器中在移除Node的时候已经会移除其上的event了，但是在老的浏览器，特别是 IE 上会有这个 bug)

这个问题我暂时也是不太清除为什么会引用外部的变量，初步怀疑是因为会引用dom的相关变量。上述的问题只在老的浏览器中存在，目前的新的浏览器已经清除event的情况下可以不考虑这个问题。

```javascript
// 解决方案，手动清除掉引用关系
myObject.element = null;
element.o = null;

window.onload = function outerFunction() {
    var obj = document.getElementById("element");
    obj.onclick = function innerFunction() {};
    obj = null;
};
```


#### 内存管理

1、什么时候触发垃圾回收

垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。IE6的垃圾回收是根据内存分配量运行的，当环境中存在256个变量、4096个对象、64k的字符串任意一种情况的时候就会触发垃圾回收器工作，看起来很科学，不用按一段时间就调用一次，有时候会没必要，这样按需调用不是很好吗？但是如果环境中就是有这么多变量等一直存在，现在脚本如此复杂，很正常，那么结果就是垃圾回收器一直在工作，这样浏览器就没法儿玩儿了。

微软在 IE7 中做了调整，触发条件不再是固定的，而是动态修改的，初始值和 IE6 相同，如果垃圾回收器回收的内存分配量低于程序占用内存的15%，说明大部分内存不可被回收，设的垃圾回收触发条件过于敏感，这时候把临界条件翻倍，如果回收的内存高于 85%，说明大部分内存早就该清理了，这时候把触发条件置回。这样就使垃圾回收工作职能了很多

2、合理的回收方案是？

###### 基础方案：

Javascript 引擎基础GC方案是（simple GC）：mark and sweep（标记清除），即：

1.遍历所有可访问的对象

2.回收已不可访问的对象

###### GC的缺陷

和其他语言一样，JS 的 GC 策略也无法避免一个问题：GC 时，停止响应其他操作，这是为了安全考虑。而 Javascript 的 GC 在 100ms 甚至以上，对一般的应用还好，但对于 JS 游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免GC造成的长时间停止响应。

###### GC优化策略
1.分代回收（Generation GC）

这个和Java回收策略思想是一致的，也是V8所主要采用的。目的是通过区分“临时”与“持久”对象；多回收“临时对象”区（young generation），少回收“持久对象”区（tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时。如图：

![image](https://i.ibb.co/CJFSGV5/generation.png)

这里需要补充的是：对于 tenured generation 对象，有额外的开销：把它从 young generation 迁移到 tenured generation，另外，如果被引用了，那引用的指向也需要修改。这里主要内容可以参考深入浅出Node中关于内存的介绍，很详细~

2.增量GC

这个方案的思想很简单，就是“每次处理一点，下次再处理一点，如此类推”。如图：

![image](https://i.ibb.co/JxxjCZQ/splice.png)

这种方案，虽然耗时短，但中断较多，带来了上下文切换频繁的问题。因为每种方案都其适用场景和缺点，因此在实际应用中，会根据实际情况选择方案。比如：低 (对象/s) 比率时，中断执行GC的频率，simple GC更低些；如果大量对象都是长期“存活”，则分代处理优势也不大。

参考地址:

https://mp.weixin.qq.com/s/kwHuP8qrruzUxC0vOKdJxA
